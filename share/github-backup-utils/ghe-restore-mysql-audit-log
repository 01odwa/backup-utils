#!/usr/bin/env bash
#/ Usage: ghe-restore-mysql-audit-log
#/ Restore MySQL audit logs.
#/
#/ Note: This command typically isn't called directly. It's invoked by
#/ ghe-restore-audit-log
set -e

# Bring in the backup configuration
base_path="$( dirname "${BASH_SOURCE[0]}" )"
# shellcheck source=share/github-backup-utils/ghe-backup-config
. "${base_path}/ghe-backup-config"

# Show usage and bail with no arguments
[ $# -lt 1 ] && print_usage "$@"

GHE_HOSTNAME="$1"

# Setup GHE_REMOTE_XXX variables, snapshot_dir and skip_prepare
setup(){
  # Perform a host-check and establish GHE_REMOTE_XXX variables.
  ghe_remote_version_required "$GHE_HOSTNAME"

  snapshot_dir="$GHE_DATA_DIR/$GHE_RESTORE_SNAPSHOT/audit-log-mysql"
  skip_prepare=false
}

# Use ghe-export-audit-logs to fetch the current metadata for all stored
# months in MySQL. For each month: number of entries, minum ID, maximum ID
fetch_current_meta(){
  local meta
  if ! meta=$(ghe-ssh "$GHE_HOSTNAME" "sudo ghe-export-audit-logs months" 2>&3); then
    ghe_verbose "Error: failed to retrieve audit log metadata"
    return
  fi

  [ -z "$meta" ] && return 1

  echo "$meta"
}

# Read the audt log metadata for all stored months in the current snapshot
fetch_snapshot_meta(){
  local indices
  if ! indices=$(cat "${snapshot_dir}"/*.meta 2>/dev/null); then
    ghe_verbose "Snapshot doesn't contain MySQL audit log dumps"
    return 1
  fi

  echo "$indices"
}

# Return metadata of months that need to be restored by
# checking snapshot's metadata vs intances's.
# i.e: metadata doesn't match or doesn't exist in MySQL
# This allows us to do a incremental restore.
notsynced_meta(){
  local snapshot_meta
  if ! snapshot_meta=$(fetch_snapshot_meta); then
    return
  fi

  local current_meta
  if ! current_meta=$(fetch_current_meta); then
    ghe_verbose "Current instance doesn't have any audit log entries in MySQL"
    skip_prepare=true
    echo "$snapshot_meta"
    return
  fi

  IFS=$'\n'
  for m in $snapshot_meta; do
    if echo "$current_meta" | grep -qx "$m"; then
      ghe_verbose "$m is in sync"
      continue
    fi

    ghe_verbose "$m is NOT in sync"
    echo "$m"
  done
  unset IFS
}

# Prepare restore: remove audit entries that match the month to be restored to
# avoid ID collisions
prepare_month_restore(){
  local month=$1
  local meta=$2

  # If table doesn't exist in the first place, we don't need
  # to delete anything
  if $skip_prepare; then
    return
  fi

  if ! ghe-ssh "$GHE_HOSTNAME" "sudo ghe-export-audit-logs prepare_restore $meta" 2>&3; then
    ghe_verbose "failed to run ghe-export-audit-logs prepare_restore $meta"
  fi
}

# Restore a SQL dump of audit entries
restore_dump(){
  local name=$1

  ghe_verbose "restoring ${name}.gz..."

  local dump="$snapshot_dir/${name}.gz"
  if ! test -e "$dump"; then
    ghe_verbose "snapshot is missing the $dump file"
    return 1
  fi

  # Transfer MySQL data from the snapshot to the GitHub instance and restore it on the fly
  ghe-ssh "$GHE_HOSTNAME" -- "sudo ghe-export-audit-logs restore --use-gunzip=true" 1>&3 2>&3 <"$dump"
}

# Restore a month of audit entries
restore_month(){
  local month=$1
  local meta=$2

  prepare_month_restore "$month" "$meta"
  restore_dump "$month"
}

# Restore the audit_entries table schema
restore_schema(){
  restore_dump schema
}

# Check if the export tool is available in this version
export_tool_available(){
    ghe-ssh "$GHE_HOSTNAME" "test -e /usr/local/bin/ghe-export-audit-logs"
}

# Restore table schema and audit entries
restore(){
  if ! export_tool_available; then
    ghe_verbose "ghe-export-audit-logs is not available"
    return
  fi

  restore_schema

  IFS=$'\n'
  for month in $(notsynced_meta); do
    local month_name
    month_name=$(echo "$month" | awk '{print $1}')

    restore_month "$month_name" "$month"
  done
  unset IFS
}

main(){
  bm_start "$(basename "$0")"
  setup
  restore
  bm_end "$(basename "$0")"
}

main
